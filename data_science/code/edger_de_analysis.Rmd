#!/usr/bin/env Rscript

Modify this line to briefly discribe the functionality of new_script.Rmd

Copyright (C) 2017  Martin Engqvist Lab
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code.

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*.

Setup file paths, load packages, etc.
```{r setup}
wants <- c('tidyverse', 'edgeR', 'limma', 'Glimma', 'ggplot2', 'piano', 'pheatmap', 'RColorBrewer', 'viridis', 'reshape2')
has   <- wants %in% rownames(installed.packages())
if(any(!has)) install.packages(wants[!has], repos="http://ftp.acc.umu.se/mirror/CRAN/")

########BIOCONDUCTOR DEPENDENCIES######################3

########BIOCONDUCTOR DEPENDENCIES######################3


#load all the packages
lapply(wants, require, character.only = TRUE)


#find the "code" directory, this should be one folder away from the project root
getCurrentFileLocation <-  function()
{
  this_file <- commandArgs() %>% 
    tibble::enframe(name = NULL) %>%
    tidyr::separate(col=value, into=c("key", "value"), sep="=", fill='right') %>%
    dplyr::filter(key == "--file") %>%
    dplyr::pull(value)
  if (length(this_file)==0 && rstudioapi::isAvailable())
  {
    this_file <- rstudioapi::getSourceEditorContext()$path
  }
  return(dirname(this_file))
}
folder_vec <- unlist(strsplit(getCurrentFileLocation(), "/"))
code_folder_location <- tail(which(folder_vec == "code"), n=1)
code_folder_location <- paste(folder_vec[1:code_folder_location], collapse = '/')
setwd(code_folder_location)

#go one folder up and set as project root directory
setwd("../")
PROJ <- getwd()
setwd(paste0(PROJ, '/data/'))

#set folder paths relative to the project root
CURRENT <- getwd()
DATA <- getwd()
RAW_EXTERNAL <- paste0(DATA, '/raw_external/')
RAW_INTERNAL <- paste0(DATA, '/raw_internal/')
INTERMEDIATE = paste0(DATA, '/intermediate/')
FINAL = paste0(DATA, '/final/')

RESULTS <- paste0(PROJ, '/results/')
FIGURES <- paste0(RESULTS, 'figures/')
PICTURES <- paste0(RESULTS, 'pictures/')
```


# Differential expression analysis 

## Data:

The data used in this notebook comes from the supplementary material of this paper: blabla
It is resampled from counts that represent means and standard deviations.

## Why EdgeR?
- Uses count data 
- does not use empirical models to moderate variances
- 

```{r Differential Expression analysis}
####################################################################################
# Differential expression study starting from  count matrices 
####################################################################################

cli = length(args) == 0

####################################################################################
# pre-processing (should in future be done in python and should only translate to matrix)
####################################################################################

# read in raw data from file
count_matrix_df = read.csv(paste0(RAW_INTERNAL, "proteomics/protein_values.csv"))

# remove repeated value
count_matrix_df <- count_matrix_df[!duplicated(count_matrix_df$Gene),]
count_matrix_df <- count_matrix_df[!is.na(count_matrix_df$Gene),]
count_matrix_df$Gene <- toupper(count_matrix_df$Gene)

start_column = grep("\\Glucose\\b", colnames(count_matrix_df))
end_column = grep("\\Fructose\\b", colnames(count_matrix_df))

start_column_unc = grep("\\Glucose.1\\b", colnames(count_matrix_df))
end_column_unc = grep("\\Fructose.1\\b", colnames(count_matrix_df))


# extract uncertainty values from data
unc_matrix = data.matrix(count_matrix_df[,start_column_unc[1]:end_column_unc[1]])



####################################################################################
# Data computed from mean and std values  
####################################################################################

# read in file provided on the command line
args = commandArgs(trailingOnly=TRUE)
print(args)
data = args[1]

results_path = args[2]


## Calculate the Counts Per Million measure
# myCPM <- cpm(countdata)


# Subset the rows of countdata without nan values
counts.keep <- count_matrix_df[,start_column[1]:end_column[1]]
# set rownames to uniprot id
rownames(counts.keep) <- count_matrix_df$Gene
unc_matrix <- unc_matrix[complete.cases(counts.keep),]
counts.keep <- counts.keep[complete.cases(counts.keep),]
col_group <- rep(1:3, each=22)

# fake counts 
fake_counts = matrix(nrow=nrow(counts.keep), ncol = ncol(counts.keep)*2)
for(i in 0:1){
  for(j in 1:nrow(fake_counts)){
    for(k in 1:ncol(counts.keep)){
      fake_counts[j,k+(i*ncol(counts.keep))] = round(rnorm(1, counts.keep[j,k],unc_matrix[j,k]))
    }
  }
}

counts.keep <- cbind(counts.keep, as.data.frame(fake_counts))
colnames(counts.keep) <- sapply(c(1:dim(counts.keep)[2]), function(x) paste(colnames(counts.keep)[x], col_group[x], sep = ""))

## Convert to an edgeR object
group <- rep(1:22, 3)
dgeObj <- DGEList(counts.keep, group = group)

## Perform TMM normalisation
dgeObj <- calcNormFactors(dgeObj)




####################################################################################
# create design matrix from data matrix 
####################################################################################
# assuming rownames as treatments
treatments = colnames(count_matrix_df[,start_column[1]:end_column[1]])

design <- rbind(model.matrix(~ -1 + treatments), model.matrix(~ -1 + treatments), model.matrix(~ -1 + treatments))

# all against all combinations
# combs = c(paste(combn(colnames(countdata), 2)[1,], "-",  combn(colnames(countdata), 2)[2,], sep = ""))

# all against glucose combinations 
combs = sapply(treatments[2:length(treatments)], function(x){paste(x, "-Glucose", sep = "")}, USE.NAMES = FALSE)

# stress analysis against glucose
# combs = sapply(treatments[15:17], function(x){paste(x, "-Glucose", sep = "")}, USE.NAMES = FALSE)

# all stationary phase 


# glucose vs complex (LB)


# all chemostat


contr = makeContrasts(contrasts = combs, levels = factor(treatments))

####################################################################################
# estimate dispersion of the data  
####################################################################################

dgeObj <- estimateCommonDisp(dgeObj)
dgeObj <- estimateGLMTrendedDisp(dgeObj)
dgeObj <- estimateTagwiseDisp(dgeObj)


  plotBCV(dgeObj)
  plotMDS(dgeObj)

####################################################################################
# testing for differential expression
####################################################################################
# fit a linear model (generalized)
names(fit)
head(coef(fit))

# create test results for all contrasts 
# results = as.data.frame(matrix(0, ncol = 0, nrow = dim(dgeObj$counts)[1]))
results = data.frame(matrix(nrow=nrow(counts.keep), ncol=0))
rownames(results) = rownames(counts.keep)

# p-values and fch as directions
results_pValues = data.frame(matrix(nrow=nrow(counts.keep), ncol=0))
rownames(results_pValues) = rownames(counts.keep)
results_directions = data.frame(matrix(nrow=nrow(counts.keep), ncol=0))
rownames(results_directions) = rownames(counts.keep)

for(i in 1:dim(contr)[2]){
  # fit using generalized linear model
  fit <- glmFit(dgeObj, design)
  lrt.BvsL <- glmLRT(fit, contrast = contr[,i])
  
  # results for overrepresentation analysis 
  results[colnames(contr)[i]] = decideTests(lrt.BvsL, p.value=0.01)
  
  # results for Gene set enrichment analysis
  # results need to be ordered as defined in the results df above
  results_pValues[colnames(contr)[i]] = topTags(lrt.BvsL, n = dim(dgeObj$counts)[1])$table[order(rownames(topTags(lrt.BvsL, n = dim(dgeObj$counts)[1])$table)),]$FDR
  results_directions[colnames(contr)[i]] = topTags(lrt.BvsL, n = dim(dgeObj$counts)[1])$table[order(rownames(topTags(lrt.BvsL, n = dim(dgeObj$counts)[1])$table)),]$logFC
  
  }

```















Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

